# 14장 노드 기반 자료 구조
컴퓨터의 자료구조는 노드 기반으로 이루어져 있다.
노드 기반 자료구조인 연결 리스트(linked list)에 대해서 알아보자.

## 1. 연결 리스트
연결 리스트는 밖에서 봤을때는 배열과 같아보이지만, 안에서 보면 배열과 많이 다르다.
연결 리스트는 노드라는것이 연결된 형태로 이루어져 있는데
노드의 헤드에는 데이터 테일(꼬리)에는 다음 노드의 주소가 저장되어 있다.

즉, 연결 리스트는 다음 노드를 가리키는 노드의 체인형태의 자료구조이다.

## 2. 읽기,검색,삽입,삭제
연결 리스트의 읽기는 배열보다 효율성이 떨어진다.
그 이유는 배열에서는 첫번째 주소와 인덱스를 알면 한번에 해당 데이터 위치로 이동할 수 있었지만, 연결 리스트는 인덱스 위치까지 가기 위해서 노드들을 하나씩 거쳐가면서 이동해야 하기 때문에 O(N)의 효율성으로 배열보다는 조금 느리다.

검색은 배열과 마찬가지로 O(N)의 효율성을 갖는다.

삽입은 첫번째 인덱스에 삽입할 때는 연결 리스트의 첫번째 노드만 바꿔주면 되기 때문에 O(1)로 굉장히 빠르지만 마지막 인덱스에 삽입할 때에는 마지막 인덱스까지 노드 사슬을 따라 접근해야 하기 때문에 O(N)만큼의 시간이 걸린다.

삭제또한 첫번째 인덱스를 삽입할 경우에는 O(1)만큼의 시간이 걸리지만 마지막 인덱스의 데이터를 삭제할 경우에는 O(N)만큼의 시간이 걸린다,

## 3. 연결 리스트의 효율성
그냥 보면 연결 리스트는 배열보다 좋을게 없어보이는데, 왜 사용할까?
그 이유는 연결 리스트가 전체 데이터를 순회하면서 데이터를 삽입하거나 삭제할 때 배열보다 효율성이 높기 때문이다.

예를들어 1000개의 데이터가 있는 배열에서 4라는 값들을 모두 삭제한다고 하면, 배열은 0인덱스부터 999인덱스까지 이동하면서 데이터를 삭제할것이다. 그리고 데이터를 삭제할때마다 삭제된 인덱스 뒤에 있는 모든 데이터들을 좌측으로 쉬프트 해줘야 한다.

그러나, 링크드리스트를 사용하면 이러한 비효율성이 사라진다.
그냥 삭제한 후에 이 전 노드의 Tail이 가리키는 주소를 다음 노드로 지정하면 끝이다.

삽입도 마찬가지다.

## 4. 이중 연결 리스트
이중 연결 리스트는 가장 기본적인 연결 리스트를 발전시킨 방법이다.
기존 연결 리스트의 노드들이 다음 노드의 주소만 가리키고 있었다면 이중 연결 리스트의 노드들은 이전 노드와 다음 노드의 데이터를 모두 저장하고 있는다.

이렇게 되면 이중 연결 리스트는 배열을 읽을 때 앞에서 부터 읽어도 되고 뒤에서 부터 읽어도 되기 때문에 효율성이 굉장히 올라간다.

## 5. 이중 연결 리스트 기반의 큐
이전에 설명했던 큐는 LIFO 방식으로 데이터를 읽고 삽입한다.
만약 배열로 큐를 제작하게 된다면, 삽입 (Last in)일 경우에는 O(1) 이고 읽기(삭제)할 경우에는 시프트 동작 때문에 O(N)의 시간이 걸린다.

그러나, 이중 연결 리스트로 큐를 제작하게 된다면, 삽입 (Last in)일 경우에는 O(1) 이고 읽기(삭제)할 경우에도 O(1)의 시간을 갖게 된다.

즉, 큐를 구현하기에 가장 이상적인 자료구조형태이다.